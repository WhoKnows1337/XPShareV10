# XPShareV10 - MCP-Driven Development Guide

**Version:** 2.0 | **Status:** 98% Complete | **Focus:** MCP-First, Memory-Driven

---

## ğŸ¯ Project Context

**XPShareV10** ist eine Experience-Sharing-Plattform fÃ¼r paranormale/auÃŸergewÃ¶hnliche Erlebnisse mit AI-powered Pattern Discovery.

**Tech Stack:** Next.js 15, Supabase, Neo4j, OpenAI, Mapbox
**Architecture:** App Router, Server Components, TypeScript, Tailwind, shadcn/ui

ğŸ’¡ **FÃ¼r Details:** Nutze Serena Memories!
```bash
# Serena Memories verfÃ¼gbar:
- project_overview        # Was ist XPShareV10, Features, Status
- tech_stack             # Complete dependencies & versions
- code_style_conventions # TypeScript rules, naming, imports
- project_structure      # Folder organization
- task_completion_checklist
- suggested_commands
```

---

## ğŸ¤– Autonomous Agent Mode

**Als autonomous agent wirst du:**

1. **vibe_check** aufrufen nach Planning und VOR major actions
2. **Full user request + current plan** bereitstellen beim vibe_check
3. **vibe_learn** nutzen um resolved issues zu dokumentieren (optional)
4. **Complete Testing Protocol** nach JEDER Implementation ausfÃ¼hren (Frontend, Backend, DB, Integration)

**Warum:** Research zeigt: Agents mit Vibe Check verbessern Success Rate (27% â†’ 54%) und halbieren harmful actions (83% â†’ 42%).

**Wann vibe_check aufrufen:**
- âœ… Nach Planning, vor Implementation
- âœ… Bei komplexen/unklaren Tasks
- âœ… Vor high-risk Ã„nderungen (DB migrations, major refactors)
- âœ… Wenn du unsicher bist Ã¼ber den Approach

**Wann vibe_learn nutzen:**
- Nach Fehlern/Mistakes (Kategorie: z.B. "Premature Implementation")
- Nach erfolgreichen LÃ¶sungen (Kategorie: "Success")
- FÃ¼r User-PrÃ¤ferenzen (Kategorie: "Preference")

---

## ğŸ”§ MCP-First Development (CORE PRINCIPLE!)

### **1. Serena MCP - Code Navigation & Editing**
**IMMER verwenden statt cat/grep/find!**

```yaml
Workflow:
  1. list_memories                    # Check available memories
  2. read_memory("project_overview")  # Get context
  3. get_symbols_overview(file)       # Understand structure
  4. find_symbol("Class/method")      # Navigate precisely
  5. replace_symbol_body(...)         # Edit symbolically
  6. think_about_collected_information # Validate understanding

CRITICAL Rules:
  âœ… Read memories BEFORE exploring code
  âœ… Use symbolic tools (find_symbol) NOT full file reads
  âœ… search_for_pattern only wenn Symbol-Name unbekannt
  âŒ NEVER read entire files unless absolutely necessary
  âŒ NEVER use grep/find bash commands for code
```

### **2. Supabase MCP - Database Operations**
**IMMER verwenden statt manueller Console!**

```yaml
Workflow:
  1. search_docs(query)          # Supabase-specific questions
  2. list_tables()               # Check schema
  3. apply_migration(name, sql)  # Schema changes
  4. execute_sql(query)          # Test queries

CRITICAL RLS Rules:
  âœ… ALWAYS: ALTER TABLE x ENABLE ROW LEVEL SECURITY
  âœ… Performance: Use (select auth.uid()) = user_id
  âœ… Test policies mit unique user IDs (kein DB reset!)
  âŒ NEVER bypass RLS (auÃŸer bei expliziter Anfrage)
  âŒ NEVER use service_role key client-side
```

**Migration Template:**
```sql
-- apply_migration: create_experiences_table
CREATE TABLE experiences (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id),
  ...
);

CREATE INDEX idx_experiences_user_id ON experiences(user_id);

ALTER TABLE experiences ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users see own experiences"
  ON experiences FOR SELECT
  TO authenticated
  USING ((select auth.uid()) = user_id);
```

### **3. GitHub MCP - Version Control**

```yaml
Key Tools:
  - search_code      # Cross-repo searches (better than grep!)
  - list_issues      # Filter: assignee:"me", state:"open"
  - create_pull_request
  - get_commit(include_diff: true)

Rules:
  âœ… search_code fÃ¼r symbolische Suchen
  âœ… PRs mit ausfÃ¼hrlichen Descriptions
  âŒ NEVER --force push ohne User-Approval
  âŒ NEVER bypass hooks (--no-verify)
```

### **4. Linear MCP - Issue Tracking**

```yaml
Key Tools (21 verfÃ¼gbar!):
  - create_issue     # AussagekrÃ¤ftige Titles
  - list_issues      # Filter: assignee:"me"
  - update_issue     # Status changes
  - Kann Dependencies zwischen Issues managen
```

### **5. Exa MCP - AI-Powered Search**

```yaml
Tools:
  - get_code_context_exa  # Library/API Docs (IMMER aktuell!)
  - web_search_exa        # General research

Usage:
  âœ… "dynamic" token mode fÃ¼r Effizienz (default)
  âœ… Nutzen wenn Supabase/GitHub Docs nicht reichen
```

### **6-9. Weitere MCPs (Situativ)**

```yaml
Browser MCP - Frontend Testing:
  Wann testen:
    âœ… Nach JEDER grÃ¶ÃŸeren Implementation
    âœ… Vor jedem Commit
    âœ… Wenn Features eingebaut werden (nicht nur UI!)

  Standard Flow:
    1. npm run dev (ensure server running)
    2. navigate("http://localhost:3000/[page]")
    3. snapshot() # Get element references
    4. Test interactions (click, type, etc.)
    5. get_console_logs() # Check for errors!
    6. screenshot() # Visual validation

  Tools: navigate, snapshot, click, type, hover, select_option,
         press_key, wait, get_console_logs, screenshot

Vibe Check MCP - Metacognitive Oversight:
  âœ… ALWAYS nach Planning, vor major actions (autonomous agent!)
  âœ… Provide: userPrompt, goal, plan, progress, uncertainties
  âœ… Use sessionId fÃ¼r State-Tracking
  âœ… vibe_learn nach Mistakes/Success (optional)

  Workflow:
    1. Plan erstellen
    2. vibe_check(goal, plan, userPrompt) aufrufen
    3. Feedback evaluieren & anpassen
    4. Implementation starten
    5. Bei Issues: vibe_learn(mistake, category, solution)

Semgrep MCP - Security Scanning:
  âœ… semgrep_scan vor PRs (Security)
  âœ… semgrep_scan_with_custom_rule fÃ¼r spezifische Checks

IDE MCP - Diagnostics:
  âœ… getDiagnostics nach Code-Ã„nderungen
  âœ… executeCode fÃ¼r Jupyter/Python Testing
```

---

## ğŸ’» Code Standards (Compact)

```yaml
TypeScript:
  - Strict mode: NO `any`, explicit return types
  - Interfaces: PascalCase (e.g., Experience)

Files:
  - Components: kebab-case.tsx (e.g., experience-card.tsx)
  - Server Components: Default (use 'use client' nur wenn needed)

Structure:
  app/[locale]/(main)/...    # Main routes
  components/ui/             # shadcn/ui primitives
  lib/supabase/              # DB client (client.ts, server.ts)

Imports Order:
  1. External (React, Next.js)
  2. Internal (@/lib/*)
  3. Components (@/components/*)
  4. Types, Utils

i18n:
  - next-intl with [locale] routes (DE, EN, FR, ES)
  - Use useTranslations() hook
```

ğŸ’¡ **Details:** Read Serena memory `code_style_conventions`

---

## ğŸš€ Development Workflow

```yaml
1. UNDERSTAND:
   - list_memories â†’ read_memory(relevant)
   - find_symbol zur Code-Location

2. PLAN:
   - vibe_check bei komplexen Tasks
   - TodoWrite fÃ¼r Multi-Step Tasks

3. IMPLEMENT:
   - Serena fÃ¼r Code-Navigation/Editing
   - Supabase MCP fÃ¼r DB-Changes
   - Follow code_style_conventions

4. TEST (CRITICAL - NEVER SKIP!):
   Nach JEDER grÃ¶ÃŸeren Implementation:

   a) Type Safety:
      - npm run type-check (ALWAYS first!)
      - IDE MCP: getDiagnostics

   b) Frontend Testing (Browser MCP):
      - Ensure dev server: npm run dev
      - navigate â†’ snapshot â†’ test interactions
      - get_console_logs() # No errors?
      - screenshot() # Visual check
      - Report: "âœ… No errors, feature works"

   c) Backend/API Testing:
      - Supabase MCP: execute_sql(test queries)
      - API Routes: Test via curl/fetch
      - RLS Policies: Test with different user IDs
      - Check response codes (200, 401, etc.)

   d) Database Validation (Supabase MCP):
      - list_tables() # Schema correct?
      - execute_sql("SELECT * FROM ... WHERE id = '...'")
      - Verify data inserted/updated correctly

   e) Integration Testing:
      - End-to-End flow (z.B. Submit â†’ DB â†’ Feed)
      - Cross-feature validation

   f) Security:
      - semgrep_scan (vor PRs)

   g) Metacognitive Check:
      - vibe_check(progress="Testing complete", uncertainties=[])

5. COMMIT:
   - GitHub MCP fÃ¼r PRs
   - Include Co-Authored-By (automatic)
```

---

## âš¡ Common Commands

```bash
# Development
npm run dev                  # Start dev server (localhost:3000)
npm run build                # Production build
npm run lint                 # ESLint check
npm run type-check           # TypeScript validation

# Supabase (MCP preferred!)
npx supabase db push         # Apply migrations
npx supabase gen types typescript --local > lib/types/database.ts

# Testing
npm run test                 # Vitest unit tests
```

---

## âš ï¸ CRITICAL RULES (Never Violate!)

```yaml
ALWAYS:
  âœ… Use Serena Memories before exploring code
  âœ… Use MCP tools (Serena, Supabase, GitHub) over bash
  âœ… Enable RLS on ALL user-facing tables
  âœ… Server Components by default
  âœ… TypeScript strict mode (no `any`)
  âœ… Test ALL implementations (Frontend, Backend, DB) BEFORE committing
  âœ… Use Browser MCP + Supabase MCP for comprehensive testing
  âœ… Test keyboard navigation & mobile responsiveness

NEVER:
  âŒ Read entire files when symbolic tools available
  âŒ Skip RLS policies (security risk!)
  âŒ Use `any` in TypeScript
  âŒ Hardcode API keys (use env vars)
  âŒ Bypass git hooks without permission
  âŒ Create files without checking PROJECT-STRUCTURE memory
```

---

## ğŸ“š When Docs Needed

**Primary Source:** Serena Memories (list_memories)

**If memory insufficient:**
- Supabase: `mcp__supabase__search_docs(query)`
- APIs/Libraries: `mcp__exa__get_code_context_exa(query)`
- General Research: `WebSearch` or `mcp__exa__web_search_exa`

**Avoid:** Reading outdated docs in `/docs/` folder

---

## ğŸ¯ Current Focus (Live Status)

- âœ… **Phase 0-2:** Foundation, Submission Flow, Feed & Discovery
- âœ… **Phase 5:** Gamification (XP, Badges, Levels)
- ğŸ”¨ **Phase 4:** Experience Detail Pages (80%)
- ğŸ“‹ **TODO:** Pattern Discovery, Admin Panel, Testing

ğŸ’¡ **Check real status:** Read Serena memory `project_overview`

---

**Last Updated:** 2025-01-16
**Philosophy:** MCP-First, Memory-Driven, Vibe-Checked, Test-Driven
**Lines:** ~350 (including comprehensive testing protocol)
